{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport _ from 'lodash';\nimport moment from 'moment';\nimport { VideoStreamStatus } from './models';\nimport { selectIsLoggedIn } from '../../userSecurity/token/selectors';\nimport { selectHasWatchItAll } from '../../payments/subscriptions/selectors';\n// based on the path lookup the tag\nexport const selectPathTagIndex = state => {\n  var _state$router, _state$router$locatio;\n\n  let pathname = (_state$router = state.router) === null || _state$router === void 0 ? void 0 : (_state$router$locatio = _state$router.location) === null || _state$router$locatio === void 0 ? void 0 : _state$router$locatio.pathname;\n\n  if (pathname === undefined) {\n    pathname = '/home';\n  }\n\n  if (pathname === '/') pathname = '/home';\n\n  let tagMatch = _.find(state.content.tags.pathIndex, function (element) {\n    return element.index === pathname;\n  });\n\n  return tagMatch;\n};\nexport const selectMainTag = state => {\n  let pathTagIndex = selectPathTagIndex(state);\n  if (pathTagIndex === undefined) return undefined;\n  let result = pathTagIndex.tag;\n  return result;\n};\nexport const selectTag = (state, tagId) => {\n  if (tagId === undefined) return undefined;\n\n  const foundTagIndex = _.find(state.content.tags.uuidIndex, tagIndex => tagIndex.index === tagId);\n\n  if (foundTagIndex !== undefined) {\n    return foundTagIndex.tag;\n  }\n\n  return undefined;\n};\nexport const selectParentTag = (state, tagId) => {\n  if (tagId === undefined) return undefined;\n\n  const mainTagIndex = _.find(state.content.tags.uuidIndex, tagIndex => tagIndex.index === tagId);\n\n  if (mainTagIndex !== undefined && mainTagIndex.parentIndex !== undefined) {\n    const parentTagInex = _.find(state.content.tags.uuidIndex, tagIndex => tagIndex.index === mainTagIndex.parentIndex);\n\n    return parentTagInex === null || parentTagInex === void 0 ? void 0 : parentTagInex.tag;\n  }\n\n  return undefined;\n};\n\nconst addStreams = (allStreams, result, indexes, currentTag, level) => {\n  if (level > 4) return; // TODO: const for Hard Limit\n\n  allStreams.forEach(stream => {\n    if (stream.browseTags.indexOf(currentTag.id) >= 0) {\n      const key = `${stream.startTime}+${stream.name}`;\n\n      if (!indexes.includes(key)) {\n        indexes.push(key);\n        result.push(_objectSpread({}, stream));\n      }\n    }\n\n    if (currentTag.children && currentTag.children.length > 0) {\n      currentTag.children.forEach(child => addStreams(allStreams, result, indexes, child, level + 1));\n    }\n  });\n};\n\nexport const selectMainTagStreams = (state, mainTag) => {\n  var _state$content$tags$s;\n\n  let result = [];\n  let indexes = [];\n  if (mainTag === undefined) return result;\n  result = (_state$content$tags$s = state.content.tags.streams) === null || _state$content$tags$s === void 0 ? void 0 : _state$content$tags$s.filter(stream => {\n    return stream.browseTags.includes(mainTag.id);\n  });\n  result = _.sortBy(result, [function (o) {\n    return moment(o.startTime).unix();\n  }]);\n  return result || [];\n};\nexport const selectTagsChildStreams = (state, mainTag) => {\n  let result = [];\n  if (mainTag === undefined) return result;\n  const childTags = mainTag.children;\n  if (childTags === undefined) return result;\n  childTags.forEach(childTag => {\n    var _state$content, _state$content$tags, _state$content$tags$s2;\n\n    const childTagStreams = (_state$content = state.content) === null || _state$content === void 0 ? void 0 : (_state$content$tags = _state$content.tags) === null || _state$content$tags === void 0 ? void 0 : (_state$content$tags$s2 = _state$content$tags.streams) === null || _state$content$tags$s2 === void 0 ? void 0 : _state$content$tags$s2.filter(stream => stream.browseTags.includes(childTag.id));\n    childTagStreams === null || childTagStreams === void 0 ? void 0 : childTagStreams.map(st => {\n      var _result;\n\n      return (_result = result) === null || _result === void 0 ? void 0 : _result.push(st);\n    });\n  });\n  result = _.sortBy(result, [function (o) {\n    return moment(o.startTime).unix();\n  }]);\n  return result || [];\n};\nexport const selectTeams = state => {\n  const teams = _.find(state.content.tags.tree, t => t.name === 'Teams');\n\n  if ((teams === null || teams === void 0 ? void 0 : teams.children) === undefined) return undefined;\n  return teams.children;\n};\nexport const selectTagByName = (state, name) => {\n  const tagPathIndex = _.find(state.content.tags.pathIndex, t => t.index === `/${name}`);\n\n  if (tagPathIndex === undefined) return undefined;\n  return tagPathIndex.tag;\n};\nexport const selectHasLoaded = state => {\n  return state.content.tags.hasLoadedStreams && state.content.tags.hasLoadedTags;\n};\nexport const getTagsFull = (tagIds, uuidIndex) => {\n  let result = [];\n\n  if (tagIds) {\n    tagIds.forEach(tag => {\n      const foundTagIndex = _.find(uuidIndex, tagIndex => tagIndex.index === tag);\n\n      if (foundTagIndex !== undefined) {\n        result.push(foundTagIndex.tag);\n      }\n    });\n  }\n\n  return result;\n};\n\nconst incluesAny = (list1, list2) => {\n  list2.forEach(tag => {\n    if (list1.includes(tag.id)) return true;\n  });\n  return false;\n};\n\nexport const selectVideoStreamStatus = (state, stream) => {\n  var _state$payments$subsc2, _state$payments$subsc3;\n\n  if (!stream) return VideoStreamStatus.NotPurchased; // find the stream\n\n  const isLoggedIn = selectIsLoggedIn(state.userSecurity.token);\n  if (!stream) return VideoStreamStatus.NotPurchasedNotLoggedIn; // is it free? yes!\n\n  if (stream.isFreeToWatch) {\n    if (isLoggedIn) {\n      return VideoStreamStatus.Free;\n    } else {\n      return VideoStreamStatus.FreeNotLoggedIn;\n    }\n  }\n\n  let result = VideoStreamStatus.NotPurchased;\n  stream.browseTags.forEach(tagId => {\n    const tag = selectTag(state, tagId);\n\n    if (tag) {\n      var _state$payments$subsc;\n\n      (_state$payments$subsc = state.payments.subscriptions.items) === null || _state$payments$subsc === void 0 ? void 0 : _state$payments$subsc.forEach(item => {\n        if (item.product_id === tag.stripeProductId) {\n          result = VideoStreamStatus.Purchased;\n        }\n      });\n    }\n  });\n  let livestreamEventId = '0';\n\n  if (stream.videoStreams && stream.videoStreams.length > 0 && stream.videoStreams[0].liveStreamEventId) {\n    livestreamEventId = stream.videoStreams[0].liveStreamEventId;\n  }\n\n  (_state$payments$subsc2 = state.payments.subscriptions) === null || _state$payments$subsc2 === void 0 ? void 0 : (_state$payments$subsc3 = _state$payments$subsc2.items) === null || _state$payments$subsc3 === void 0 ? void 0 : _state$payments$subsc3.forEach(ph => {\n    var _ph$product_id;\n\n    if (((_ph$product_id = ph.product_id) === null || _ph$product_id === void 0 ? void 0 : _ph$product_id.startsWith(`${livestreamEventId}|`)) && ph.subscriptionType === 'GamePass') {\n      result = VideoStreamStatus.Purchased;\n    }\n  });\n\n  if (selectHasWatchItAll(state.payments.subscriptions, state.configuration)) {\n    result = VideoStreamStatus.Purchased;\n  } // lookup any browse tags user has purchased\n\n\n  return result;\n};\nexport const filterStreamsNoLimit = (streams, filterTag) => {\n  let filteredStreams = [];\n  if (!streams) return filteredStreams;\n\n  for (let i = streams.length - 1; i >= 0; i--) {\n    let currentStream = streams[i];\n\n    if (!filterTag || currentStream.browseTags.includes(filterTag.id) || incluesAny(currentStream.browseTags, (filterTag === null || filterTag === void 0 ? void 0 : filterTag.children) || [])) {\n      filteredStreams.push(currentStream);\n    }\n  }\n\n  filteredStreams = _.sortBy(filteredStreams, [function (o) {\n    return moment(o.startTime).unix();\n  }]);\n  return filteredStreams;\n};\nexport const filterFeaturedStreams = (streams, limit, filterTag) => {\n  let filteredStreams = [];\n\n  let tempStreams = _.filter(streams, stream => !filterTag || stream.browseTags.includes(filterTag.id) || incluesAny(stream.browseTags, (filterTag === null || filterTag === void 0 ? void 0 : filterTag.children) || []));\n\n  let futureStreams = _.chain(tempStreams).filter(stream => moment(stream.startTime).unix() > moment(new Date()).unix()).orderBy([function (o) {\n    return moment(o.startTime).unix();\n  }], ['desc']).value();\n\n  let pastStreams = _.chain(tempStreams).filter(stream => moment(stream.startTime).unix() < moment(new Date()).unix()).orderBy([function (o) {\n    return moment(o.startTime).unix();\n  }], ['asc']).value();\n\n  for (let i = futureStreams.length - 1; i >= 0; i--) {\n    let currentStream = futureStreams[i];\n\n    if ((filteredStreams === null || filteredStreams === void 0 ? void 0 : filteredStreams.length) < limit && (!filterTag || currentStream.browseTags.includes(filterTag.id)) || incluesAny(currentStream.browseTags, (filterTag === null || filterTag === void 0 ? void 0 : filterTag.children) || [])) {\n      filteredStreams.push(currentStream);\n    }\n  }\n\n  if (filteredStreams.length < limit) {\n    for (let i = pastStreams.length - 1; i >= 0; i--) {\n      let currentStream = pastStreams[i];\n\n      if ((filteredStreams === null || filteredStreams === void 0 ? void 0 : filteredStreams.length) < limit && (!filterTag || currentStream.browseTags.includes(filterTag.id)) || incluesAny(currentStream.browseTags, (filterTag === null || filterTag === void 0 ? void 0 : filterTag.children) || [])) {\n        filteredStreams.push(currentStream);\n      }\n    }\n  }\n\n  return filteredStreams;\n};\nexport const filterStreams = (streams, limit, filterTag) => {\n  let filteredStreams = [];\n  if (!streams) return filteredStreams;\n\n  for (let i = streams.length - 1; i >= 0; i--) {\n    var _filteredStreams;\n\n    let currentStream = streams[i];\n\n    if (((_filteredStreams = filteredStreams) === null || _filteredStreams === void 0 ? void 0 : _filteredStreams.length) < limit && (!filterTag || currentStream.browseTags.includes(filterTag.id)) || incluesAny(currentStream.browseTags, (filterTag === null || filterTag === void 0 ? void 0 : filterTag.children) || [])) {\n      filteredStreams.push(currentStream);\n    }\n  }\n\n  filteredStreams = _.sortBy(filteredStreams, [function (o) {\n    return moment(o.startTime).unix();\n  }]);\n  return filteredStreams;\n};\nexport const selectsavedEventIds = state => {\n  var _state$content2, _state$content2$tags;\n\n  return ((_state$content2 = state.content) === null || _state$content2 === void 0 ? void 0 : (_state$content2$tags = _state$content2.tags) === null || _state$content2$tags === void 0 ? void 0 : _state$content2$tags.savedEventIds) || [];\n};\nexport const selectSavedTagIds = state => {\n  var _state$content3, _state$content3$tags;\n\n  return ((_state$content3 = state.content) === null || _state$content3 === void 0 ? void 0 : (_state$content3$tags = _state$content3.tags) === null || _state$content3$tags === void 0 ? void 0 : _state$content3$tags.savedTagIds) || [];\n}; // Determines if stream is LIVE or not\n\nexport const isStreamLive = (startTime, duration) => {\n  // A stream is playing if it has a start-time before now\n  // and an end time after now (use the duration field, or 90 minutes if not set).\n  const streamStartTime = moment(startTime).unix() * 1000;\n  const streamEndTime = moment(startTime).add(duration, 'm').unix() * 1000;\n  const currentTime = moment(new Date()).unix() * 1000;\n  const beforeNow = streamStartTime < currentTime;\n  const afterNow = streamEndTime > currentTime;\n  return beforeNow && afterNow;\n};\nexport const selectSavedTagStreams = state => {\n  var _state$content4, _state$content4$tags;\n\n  let savedTagStreamsArray = [];\n  if (!state || !state.content || !state.content.tags || !state.content.tags.uuidIndex) return savedTagStreamsArray;\n  (_state$content4 = state.content) === null || _state$content4 === void 0 ? void 0 : (_state$content4$tags = _state$content4.tags) === null || _state$content4$tags === void 0 ? void 0 : _state$content4$tags.savedTagIds.forEach(savedTagId => {\n    const savedTagIndex = _.find(state.content.tags.uuidIndex, ti => ti.index === savedTagId);\n\n    if (savedTagIndex !== undefined) {\n      const savedTagStreams = selectMainTagStreams(state, savedTagIndex.tag);\n\n      if (savedTagStreams !== undefined) {\n        savedTagStreamsArray.push(savedTagStreams);\n      }\n    }\n  });\n  return savedTagStreamsArray;\n};\nexport const selectStreamByLivestreamEventId = (streams, livestreamEventId) => {\n  let match = _.find(streams, stream => {\n    const result = stream && stream.videoStreams && stream.videoStreams.length > 0 && stream.videoStreams[0].liveStreamEventId === livestreamEventId;\n\n    if (result || stream.name.toUpperCase() === 'SUPER EIGHT ROUND 5 GAME 4') {// console.log('result || stream.name.toUpperCase() === \\'SUPER EIGHT ROUND 5 GAME 4\\'')\n      // console.log('selectStreamByLivestreamEventId livestreamEventId ', livestreamEventId)\n      // console.log('selectStreamByLivestreamEventId result ', result)\n      // console.log('selectStreamByLivestreamEventId stream ', stream)\n    }\n\n    return result;\n  }); // console.log('selectStreamByLivestreamEventId matches ', match)\n\n\n  if (match != undefined) return match;\n  return undefined;\n};\nexport const selectSavedStreams = state => {\n  var _state$content5, _state$content5$tags, _state$content5$tags$;\n\n  let savedStreams = [];\n  if (!state || !state.content || !state.content.tags || !state.content.tags.streams) return savedStreams;\n  (_state$content5 = state.content) === null || _state$content5 === void 0 ? void 0 : (_state$content5$tags = _state$content5.tags) === null || _state$content5$tags === void 0 ? void 0 : (_state$content5$tags$ = _state$content5$tags.savedEventIds) === null || _state$content5$tags$ === void 0 ? void 0 : _state$content5$tags$.forEach(id => {\n    const stream = _.find(state.content.tags.streams, st => st.videoStreams && st.videoStreams.length > 0 && st.eventId === id);\n\n    if (stream !== undefined) {\n      savedStreams.push(stream);\n    }\n  });\n  return savedStreams;\n};\nexport const selectSavedTags = state => {\n  var _state$content6, _state$content6$tags, _state$content6$tags$;\n\n  let savedTags = [];\n  (_state$content6 = state.content) === null || _state$content6 === void 0 ? void 0 : (_state$content6$tags = _state$content6.tags) === null || _state$content6$tags === void 0 ? void 0 : (_state$content6$tags$ = _state$content6$tags.savedTagIds) === null || _state$content6$tags$ === void 0 ? void 0 : _state$content6$tags$.forEach(savedTagId => {\n    const savedTagIndex = _.find(state.content.tags.uuidIndex, ti => ti.index === savedTagId);\n\n    if (savedTagIndex !== undefined) {\n      savedTags.push(savedTagIndex === null || savedTagIndex === void 0 ? void 0 : savedTagIndex.tag);\n    }\n  });\n  return savedTags;\n};","map":{"version":3,"sources":["/Users/ognjen/Desktop/spooky-live-ssr/ui/src/services/content/tags/selectors.ts"],"names":["_","moment","VideoStreamStatus","selectIsLoggedIn","selectHasWatchItAll","selectPathTagIndex","state","pathname","router","location","undefined","tagMatch","find","content","tags","pathIndex","element","index","selectMainTag","pathTagIndex","result","tag","selectTag","tagId","foundTagIndex","uuidIndex","tagIndex","selectParentTag","mainTagIndex","parentIndex","parentTagInex","addStreams","allStreams","indexes","currentTag","level","forEach","stream","browseTags","indexOf","id","key","startTime","name","includes","push","children","length","child","selectMainTagStreams","mainTag","streams","filter","sortBy","o","unix","selectTagsChildStreams","childTags","childTag","childTagStreams","map","st","selectTeams","teams","tree","t","selectTagByName","tagPathIndex","selectHasLoaded","hasLoadedStreams","hasLoadedTags","getTagsFull","tagIds","incluesAny","list1","list2","selectVideoStreamStatus","NotPurchased","isLoggedIn","userSecurity","token","NotPurchasedNotLoggedIn","isFreeToWatch","Free","FreeNotLoggedIn","payments","subscriptions","items","item","product_id","stripeProductId","Purchased","livestreamEventId","videoStreams","liveStreamEventId","ph","startsWith","subscriptionType","configuration","filterStreamsNoLimit","filterTag","filteredStreams","i","currentStream","filterFeaturedStreams","limit","tempStreams","futureStreams","chain","Date","orderBy","value","pastStreams","filterStreams","selectsavedEventIds","savedEventIds","selectSavedTagIds","savedTagIds","isStreamLive","duration","streamStartTime","streamEndTime","add","currentTime","beforeNow","afterNow","selectSavedTagStreams","savedTagStreamsArray","savedTagId","savedTagIndex","ti","savedTagStreams","selectStreamByLivestreamEventId","match","toUpperCase","selectSavedStreams","savedStreams","eventId","selectSavedTags","savedTags"],"mappings":"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","sourcesContent":["import _ from 'lodash'\nimport moment from 'moment'\n\nimport { ITagIndex, ITag, IStream, VideoStreamStatus } from './models'\nimport { RootState } from '../../RootState'\nimport { selectIsLoggedIn } from '../../userSecurity/token/selectors'\nimport { selectHasWatchItAll } from '../../payments/subscriptions/selectors'\nimport { PurchaseHistory } from '../../payments/subscriptions/models'\nimport { Stream } from 'stream'\n\n// based on the path lookup the tag\nexport const selectPathTagIndex = (state: RootState): ITagIndex | undefined => {\n  let pathname = state.router?.location?.pathname\n\n\n  if (pathname === undefined) {\n    pathname = '/home'\n  }\n\n  if (pathname === '/') pathname = '/home'\n\n  let tagMatch = _.find(state.content.tags.pathIndex, function (element: ITagIndex) { return element.index === pathname });\n  return tagMatch\n}\n\nexport const selectMainTag = (state: RootState): ITag | undefined => {\n  let pathTagIndex = selectPathTagIndex(state)\n  if (pathTagIndex === undefined) return undefined\n  let result = pathTagIndex.tag\n\n  return result\n}\n\nexport const selectTag = (state: RootState, tagId: string | undefined): ITag | undefined => {\n  if (tagId === undefined) return undefined\n  const foundTagIndex: ITagIndex = _.find(state.content.tags.uuidIndex, (tagIndex: ITagIndex) => tagIndex.index === tagId)\n  if (foundTagIndex !== undefined) {\n    return foundTagIndex.tag\n  }\n  return undefined\n}\n\nexport const selectParentTag = (state: RootState, tagId: string | undefined): ITag | undefined => {\n  if (tagId === undefined) return undefined\n  const mainTagIndex: ITagIndex | undefined = _.find(state.content.tags.uuidIndex, (tagIndex: ITagIndex) => tagIndex.index === tagId)\n  if (mainTagIndex !== undefined && mainTagIndex.parentIndex !== undefined) {\n    const parentTagInex: ITagIndex | undefined = _.find(state.content.tags.uuidIndex, (tagIndex: ITagIndex) => tagIndex.index === mainTagIndex.parentIndex)\n    return parentTagInex?.tag\n  }\n  return undefined\n}\n\nconst addStreams = (allStreams: IStream[], result: IStream[], indexes: string[], currentTag: ITag, level: number) => {\n  if (level > 4) return // TODO: const for Hard Limit\n\n  allStreams.forEach(stream => {\n    if (stream.browseTags.indexOf(currentTag.id) >= 0) {\n      const key = `${stream.startTime}+${stream.name}`\n      if (!indexes.includes(key)) {\n        indexes.push(key)\n        result.push({ ...stream })\n      }\n    }\n\n    if (currentTag.children && currentTag.children.length > 0) {\n      currentTag.children.forEach(child => addStreams(allStreams, result, indexes, child, level + 1))\n    }\n  })\n}\n\nexport const selectMainTagStreams = (state: RootState, mainTag: ITag | undefined): IStream[] => {\n\n  let result: IStream[] | undefined = []\n  let indexes: string[] = []\n  if (mainTag === undefined) return result\n\n  result = state.content.tags.streams?.filter((stream: IStream) => {\n    return stream.browseTags.includes(mainTag.id)\n  })\n\n  result = _.sortBy(result, [function (o: IStream) { return moment(o.startTime).unix() }])\n\n  return result || []\n}\n\nexport const selectTagsChildStreams = (state: RootState, mainTag: ITag | undefined): IStream[] => {\n \n  let result: IStream[] | undefined = []\n  if (mainTag === undefined) return result\n \n  const childTags: ITag[] | undefined = mainTag.children\n  if(childTags === undefined) return result\n \n  childTags.forEach(childTag => {\n    const childTagStreams: IStream[] | undefined = state.content?.tags?.streams?.filter((stream: IStream) => (\n      stream.browseTags.includes(childTag.id)\n    ))\n    childTagStreams?.map(st => result?.push(st))\n  })\n  result = _.sortBy(result, [function (o: IStream) { return moment(o.startTime).unix() }])\n  return result || []\n}\n\nexport const selectTeams = (state: RootState): ITag[] | undefined => {\n  const teams: ITag | undefined = _.find(state.content.tags.tree, (t) => t.name === 'Teams');\n  if (teams?.children === undefined) return undefined;\n  return teams.children;\n}\n\nexport const selectTagByName = (state: RootState, name: string): ITag | undefined => {\n  const tagPathIndex: ITagIndex | undefined = _.find(state.content.tags.pathIndex, (t) => t.index === `/${name}`);\n  if(tagPathIndex === undefined) return undefined;\n  return tagPathIndex.tag;\n}\n\nexport const selectHasLoaded = (state: RootState): boolean => {\n  return state.content.tags.hasLoadedStreams && state.content.tags.hasLoadedTags\n}\n\nexport const getTagsFull = (tagIds: string[], uuidIndex: ITagIndex[]): ITag[] => {\n  let result: ITag[] = []\n  if (tagIds) {\n    tagIds.forEach((tag: string) => {\n      const foundTagIndex: ITagIndex = _.find(uuidIndex, (tagIndex: ITagIndex) => tagIndex.index === tag)\n      if (foundTagIndex !== undefined) {\n        result.push(foundTagIndex.tag)\n      }\n    })\n  }\n\n  return result\n}\n\nconst incluesAny = (list1: string[], list2: ITag[]): boolean => {\n  list2.forEach(tag => {\n    if (list1.includes(tag.id)) return true\n  })\n\n  return false\n}\n\nexport const selectVideoStreamStatus = (state: RootState, stream: IStream | undefined): VideoStreamStatus => {\n\n  if (!stream) return VideoStreamStatus.NotPurchased\n\n  // find the stream\n  const isLoggedIn = selectIsLoggedIn(state.userSecurity.token)\n\n  if (!stream) return VideoStreamStatus.NotPurchasedNotLoggedIn\n\n  // is it free? yes!\n  if (stream.isFreeToWatch) {\n    if (isLoggedIn) {\n      return VideoStreamStatus.Free\n    } else {\n      return VideoStreamStatus.FreeNotLoggedIn\n    }\n  }\n\n  let result: VideoStreamStatus = VideoStreamStatus.NotPurchased\n\n  stream.browseTags.forEach(tagId => {\n    const tag = selectTag(state, tagId)\n    if (tag) {\n      state.payments.subscriptions.items?.forEach(item => {\n        if (item.product_id === tag.stripeProductId) {\n          result = VideoStreamStatus.Purchased\n        }\n      })\n    }\n  })\n\n  let livestreamEventId = '0'\n  if (stream.videoStreams && stream.videoStreams.length > 0 && stream.videoStreams[0].liveStreamEventId) {\n    livestreamEventId = stream.videoStreams[0].liveStreamEventId\n  }\n  state.payments.subscriptions?.items?.forEach((ph: PurchaseHistory) => {\n    if (ph.product_id?.startsWith(`${livestreamEventId}|`) && ph.subscriptionType === 'GamePass') {\n      result = VideoStreamStatus.Purchased\n    }\n  })\n\n  if (selectHasWatchItAll(state.payments.subscriptions, state.configuration)) {\n    result = VideoStreamStatus.Purchased\n  }\n\n  // lookup any browse tags user has purchased\n  return result\n}\n\nexport const filterStreamsNoLimit = (streams: IStream[], filterTag: ITag | undefined): IStream[] => {\n  let filteredStreams: IStream[] = [];\n\n  if (!streams) return filteredStreams\n\n  for (let i = streams.length - 1; i >= 0; i--) {\n    let currentStream = streams[i]\n    if ((!filterTag || currentStream.browseTags.includes(filterTag.id)) || incluesAny(currentStream.browseTags, filterTag?.children || [])) {\n      filteredStreams.push(currentStream)\n    }\n  }\n\n  filteredStreams = _.sortBy(filteredStreams, [function (o: IStream) { return moment(o.startTime).unix() }])\n\n  return filteredStreams\n}\n\nexport const filterFeaturedStreams = (streams: IStream[], limit: number, filterTag: ITag | undefined) : IStream[] => {\n\n  let filteredStreams: IStream[] = [];\n  let tempStreams = _.filter(streams, stream => (!filterTag || stream.browseTags.includes(filterTag.id)) || incluesAny(stream.browseTags, filterTag?.children || []));\n  \n  let futureStreams = _.chain(tempStreams).filter(stream => moment(stream.startTime).unix() > moment(new Date()).unix()).orderBy([function (o: IStream) { return moment(o.startTime).unix() }], ['desc']).value();\n  let pastStreams = _.chain(tempStreams).filter(stream => moment(stream.startTime).unix() < moment(new Date()).unix()).orderBy([function (o: IStream) { return moment(o.startTime).unix() }],['asc']).value();\n  \n  for (let i = futureStreams.length - 1; i >= 0; i--) {\n    let currentStream = futureStreams[i]\n    if (filteredStreams?.length < limit && (!filterTag || currentStream.browseTags.includes(filterTag.id)) || incluesAny(currentStream.browseTags, filterTag?.children || [])) {\n      filteredStreams.push(currentStream)\n    }\n  }\n\n  if (filteredStreams.length < limit) {\n    for (let i = pastStreams.length - 1; i >= 0; i--) {\n      let currentStream = pastStreams[i]\n      if (filteredStreams?.length < limit && (!filterTag || currentStream.browseTags.includes(filterTag.id)) || incluesAny(currentStream.browseTags, filterTag?.children || [])) {\n        filteredStreams.push(currentStream)\n      }\n    }\n  } \n\n  \n  return filteredStreams;\n}\n\nexport const filterStreams = (streams: IStream[], limit: number , filterTag: ITag | undefined): IStream[] => {\n  let filteredStreams: IStream[] = [];\n\n  if (!streams) return filteredStreams\n\n  for (let i = streams.length - 1; i >= 0; i--) {\n    let currentStream = streams[i]\n    if (filteredStreams?.length < limit && (!filterTag || currentStream.browseTags.includes(filterTag.id)) || incluesAny(currentStream.browseTags, filterTag?.children || [])) {\n      filteredStreams.push(currentStream)\n    }\n  }\n\n  filteredStreams = _.sortBy(filteredStreams, [function (o: IStream) { return moment(o.startTime).unix() }])\n\n  return filteredStreams\n}\n\nexport const selectsavedEventIds = (state: RootState): number[] => {\n  return state.content?.tags?.savedEventIds || []\n}\n\nexport const selectSavedTagIds = (state: RootState): string[] => {\n  return state.content?.tags?.savedTagIds || []\n}\n\n// Determines if stream is LIVE or not\nexport const isStreamLive = (startTime: Date, duration: number | 90): boolean => {\n  // A stream is playing if it has a start-time before now\n  // and an end time after now (use the duration field, or 90 minutes if not set).\n\n  const streamStartTime = moment(startTime).unix() * 1000;\n  const streamEndTime = moment(startTime).add(duration, 'm').unix() * 1000;\n  const currentTime = moment(new Date()).unix() * 1000;\n\n  const beforeNow = streamStartTime < currentTime\n  const afterNow = streamEndTime > currentTime\n\n  return beforeNow && afterNow\n}\n\nexport const selectSavedTagStreams = (state: RootState): IStream[][] => {\n  let savedTagStreamsArray: IStream[][] = []\n  if (!state || !state.content || !state.content.tags || !state.content.tags.uuidIndex) return savedTagStreamsArray\n\n  state.content?.tags?.savedTagIds.forEach(savedTagId => {\n    const savedTagIndex: ITagIndex | undefined = _.find(state.content.tags.uuidIndex, (ti: ITagIndex) => ti.index === savedTagId)\n\n    if (savedTagIndex !== undefined) {\n      const savedTagStreams: IStream[] = selectMainTagStreams(state, savedTagIndex.tag)\n      if (savedTagStreams !== undefined) {\n        savedTagStreamsArray.push(savedTagStreams)\n      }\n    }\n  })\n\n  return savedTagStreamsArray\n}\n\nexport const selectStreamByLivestreamEventId = (streams: IStream[], livestreamEventId: string): IStream | undefined => {\n\n  let match: IStream = _.find(streams, (stream: IStream) => {\n\n    const result = stream && stream.videoStreams && stream.videoStreams.length > 0 && stream.videoStreams[0].liveStreamEventId === livestreamEventId\n\n    if (result || stream.name.toUpperCase() === 'SUPER EIGHT ROUND 5 GAME 4') {\n      // console.log('result || stream.name.toUpperCase() === \\'SUPER EIGHT ROUND 5 GAME 4\\'')\n      // console.log('selectStreamByLivestreamEventId livestreamEventId ', livestreamEventId)\n      // console.log('selectStreamByLivestreamEventId result ', result)\n      // console.log('selectStreamByLivestreamEventId stream ', stream)\n    }\n    return result\n  })\n\n  // console.log('selectStreamByLivestreamEventId matches ', match)\n\n  if (match != undefined) return match\n\n  return undefined\n}\n\nexport const selectSavedStreams = (state: RootState): IStream[] => {\n  let savedStreams: IStream[] = []\n  if (!state || !state.content || !state.content.tags || !state.content.tags.streams) return savedStreams\n\n  state.content?.tags?.savedEventIds?.forEach(id => {\n    const stream: IStream | undefined = _.find(state.content.tags.streams, (st: IStream) => st.videoStreams && st.videoStreams.length > 0 && st.eventId === id)\n    if (stream !== undefined) {\n      savedStreams.push(stream)\n    }\n  })\n\n  return savedStreams\n}\n\nexport const selectSavedTags = (state: RootState): ITag[] => {\n  let savedTags: ITag[] = []\n  state.content?.tags?.savedTagIds?.forEach(savedTagId => {\n    const savedTagIndex: ITagIndex | undefined = _.find(state.content.tags.uuidIndex, (ti: ITagIndex) => ti.index === savedTagId)\n\n    if (savedTagIndex !== undefined) {\n      savedTags.push(savedTagIndex?.tag)\n    }\n  })\n\n  return savedTags\n}"]},"metadata":{},"sourceType":"module"}