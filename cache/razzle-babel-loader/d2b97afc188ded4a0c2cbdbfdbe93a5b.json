{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { createReducer } from '@reduxjs/toolkit';\nimport _ from 'lodash';\nimport * as eventTypes from './eventTypes';\nimport moment from 'moment';\nimport { v4 as uuidv4 } from 'uuid';\nconst initialState = {\n  tree: undefined,\n  // filteredTree: undefined,\n  browseAll: [],\n  browseFiltered: [],\n  filters: [],\n  streams: [],\n  pathIndex: undefined,\n  uuidIndex: undefined,\n  mainTag: undefined,\n  error: '',\n  errorDescription: '',\n  hasLoadedTags: false,\n  hasLoadedStreams: false,\n  savedEventIds: [],\n  savedTagIds: [],\n  filterSearchTerm: '',\n  refreshKey: uuidv4(),\n  visitedTags: []\n};\n\nconst encodeTagName = name => {\n  /* eslint-disable */\n  return name.toLocaleLowerCase().replace(/ /gi, '-').replace(/[^0-9a-z\\-]/gi, '').replace(/[-]+/gi, '-').replace(/[-]+/gi, '-');\n  /* eslint-enable */\n};\n\nconst buildIndexes = (base, parent, tree, pathIndex, uuidIndex) => {\n  if (tree === undefined) return;\n  tree.forEach(element => {\n    // if (element.name && element.name.length > 20) element.name = element.name.substring(0, 19) + '...'\n    let path = `${base}/${encodeTagName(element.name)}`;\n    element.path = path;\n    pathIndex.push({\n      index: path,\n      parentIndex: base,\n      tag: element\n    });\n    uuidIndex.push({\n      index: element.id,\n      parentIndex: parent === null || parent === void 0 ? void 0 : parent.id,\n      tag: element\n    });\n    buildIndexes(path, element, element.children, pathIndex, uuidIndex);\n  });\n};\n\nconst setStreamTags = (streams, uuidIndex) => {\n  if (!streams) return [];\n  if (!uuidIndex) return streams; // we have a uuidIndex and streams\n  // streams.forEach(stream => {\n  // })\n\n  var sorted = _.sortBy(streams, [function (o) {\n    return o.startTime;\n  }]);\n\n  return sorted;\n};\n/*\nconst removePeers = (newFilter: string, filters: string[], uuidIndex: ITagIndex[]): string[] => {\n  // find the parent for the newFilter\n  let newFilterTag: ITagIndex = _.find(uuidIndex, (element: ITagIndex) => element.index === newFilter)\n  let parentTagId = newFilterTag.parentIndex\n  if (parentTagId === undefined) return filters\n  let parentTagIndex: ITagIndex = _.find(uuidIndex, (element: ITagIndex) => element.index === parentTagId)\n  let parentTag = parentTagIndex.tag\n\n  // build a new array that excludes all of newFilter's peers\n  let newFilters: string[] = [newFilter]\n  let peers = parentTag.children || []\n  let peerIds: string[] = []\n  peers.forEach(element => {\n    peerIds.push(element.id)\n  })\n  filters.forEach(element => {\n    if (!peerIds.includes(element)) {\n      newFilters.push(element)\n    }\n  })\n\n  return newFilters\n}\n*/\n\n\nconst addOrRemoveTag = (savedList, itemToAddOrRemove) => {\n  let newSavedList = _.cloneDeep(savedList) || [];\n\n  if (savedList === null || savedList === void 0 ? void 0 : savedList.includes(itemToAddOrRemove)) {\n    newSavedList = newSavedList.filter(item => item !== itemToAddOrRemove);\n  } else {\n    newSavedList.push(itemToAddOrRemove);\n  }\n\n  return newSavedList;\n};\n\nconst addOrRemoveStream = (savedList, itemToAddOrRemove) => {\n  let newSavedList = _.cloneDeep(savedList) || [];\n\n  if (savedList === null || savedList === void 0 ? void 0 : savedList.includes(itemToAddOrRemove)) {\n    newSavedList = newSavedList.filter(item => item !== itemToAddOrRemove);\n  } else {\n    newSavedList.push(itemToAddOrRemove);\n  }\n\n  return newSavedList;\n};\n\nconst findFilterTag = tree => {\n  let tags = [];\n  if (!tree) return [];\n\n  for (const item of tree) {\n    tags.push(item);\n\n    if (item.children && item.children.length > 0) {\n      tags.push(...findFilterTag(item.children));\n    }\n  }\n\n  return tags;\n};\n\nconst ROUTER_LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\n\nconst findRelatedTagIds = (tagId, streams, uuidIndex) => {\n  let findRelatedTagIdsResult = [];\n  streams.forEach(stream => {\n    if (stream.browseTags.includes(tagId)) {\n      stream.browseTags.forEach(browseTagId => {\n        if (!stream.lineUpTags.includes(browseTagId)) {\n          findRelatedTagIdsResult.push(browseTagId);\n\n          const tagIndex = _.find(uuidIndex, t => t.index === browseTagId);\n\n          if (tagIndex && tagIndex.parentIndex) {\n            findRelatedTagIdsResult.push(tagIndex.parentIndex);\n\n            var parent = _.find(uuidIndex, t => t.index === tagIndex.parentIndex);\n\n            if (parent && parent.parentIndex) {\n              findRelatedTagIdsResult.push(parent.parentIndex);\n\n              var grandParent = _.find(uuidIndex, t => t.index === parent.parentIndex);\n\n              if (grandParent && grandParent.parentIndex) {\n                findRelatedTagIdsResult.push(grandParent.parentIndex);\n              }\n            }\n          }\n        }\n      });\n    }\n  });\n  findRelatedTagIdsResult = _.uniq(findRelatedTagIdsResult);\n  return findRelatedTagIdsResult;\n};\n\nconst isNumeric = n => {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nconst buildBrowseAll = (tree, streams, uuidIndex) => {\n  let result = [];\n  tree.forEach(branchTag => {\n    if (!branchTag.hideFromBrowse && branchTag.streamCount !== 0) {\n      var _branchTag$parent;\n\n      let browseOption = {\n        name: branchTag.name,\n        path: branchTag.path || '',\n        tagId: branchTag.id,\n        parentTagId: ((_branchTag$parent = branchTag.parent) === null || _branchTag$parent === void 0 ? void 0 : _branchTag$parent.id) || '',\n        items: [],\n        relatedTagIds: findRelatedTagIds(branchTag.id, streams, uuidIndex) //,\n        //relatedTagNames: findRelatedTagNames(branchTag.id, streams, uuidIndex)\n\n      };\n\n      if (branchTag.children && branchTag.children.length > 0) {\n        branchTag.children.forEach(childTag => {\n          if (!childTag.hideFromBrowse && childTag.streamCount !== 0) {\n            var _childTag$parent, _childTag$children;\n\n            let childBrowseResult = {\n              name: childTag.name,\n              tagId: childTag.id,\n              parentTagId: ((_childTag$parent = childTag.parent) === null || _childTag$parent === void 0 ? void 0 : _childTag$parent.id) || '',\n              path: childTag.path || '',\n              children: [],\n              showInAccordion: true,\n              relatedTagIds: findRelatedTagIds(childTag.id, streams, uuidIndex) //,\n              //relatedTagNames: findRelatedTagNames(childTag.id, streams, uuidIndex)\n\n            };\n            browseOption.items.push(childBrowseResult);\n            (_childTag$children = childTag.children) === null || _childTag$children === void 0 ? void 0 : _childTag$children.forEach(grandChildTag => {\n              if (!grandChildTag.hideFromBrowse && grandChildTag.streamCount !== 0) {\n                var _grandChildTag$parent, _grandChildTag$childr;\n\n                let grandChildBrowseResult = {\n                  name: grandChildTag.name,\n                  tagId: grandChildTag.id,\n                  parentTagId: ((_grandChildTag$parent = grandChildTag.parent) === null || _grandChildTag$parent === void 0 ? void 0 : _grandChildTag$parent.id) || '',\n                  path: grandChildTag.path || '',\n                  children: [],\n                  showInAccordion: false,\n                  relatedTagIds: findRelatedTagIds(grandChildTag.id, streams, uuidIndex) //,\n                  //relatedTagNames: findRelatedTagNames(grandChildTag.id, streams, uuidIndex)\n\n                };\n                browseOption.items.push(grandChildBrowseResult);\n                childBrowseResult.children.push(grandChildBrowseResult);\n                (_grandChildTag$childr = grandChildTag.children) === null || _grandChildTag$childr === void 0 ? void 0 : _grandChildTag$childr.forEach(greatGrandChildTag => {\n                  var _greatGrandChildTag$p;\n\n                  let greatGrandChildResult = {\n                    name: greatGrandChildTag.name,\n                    tagId: greatGrandChildTag.id,\n                    parentTagId: ((_greatGrandChildTag$p = greatGrandChildTag.parent) === null || _greatGrandChildTag$p === void 0 ? void 0 : _greatGrandChildTag$p.id) || '',\n                    path: greatGrandChildTag.path || '',\n                    children: [],\n                    showInAccordion: false,\n                    relatedTagIds: findRelatedTagIds(greatGrandChildTag.id, streams, uuidIndex) //,\n                    //relatedTagNames: findRelatedTagNames(greatGrandChildTag.id, streams, uuidIndex)\n\n                  };\n                  grandChildBrowseResult.children.push(greatGrandChildResult);\n                });\n              }\n            });\n          }\n        });\n\n        if (browseOption.name !== 'Competitions') {\n          browseOption.items = _.sortBy(browseOption.items, bo => {\n            // Sort by numeric characters descending, then alphanumeric characters ascending\n            let sortString = '';\n\n            for (let i = 0; i < bo.name.length; i++) {\n              // if the character is a number invert it\n              if (isNumeric(bo.name[i])) {\n                let char = bo.name[i];\n                let num = parseInt(char);\n                let inv = 9 - num;\n                sortString += inv.toString();\n              } else {\n                // otherwise just add it to the sort string for comparison\n                sortString += bo.name[i];\n              }\n            }\n\n            return sortString;\n          });\n        }\n      }\n\n      result.push(browseOption);\n    }\n  });\n  return result;\n};\n\nconst filterResult = (source, filters, filterSearchTerm) => {\n  let includesAllFilters = true; // invert to change to include any filter\n\n  filters.forEach(filter => {\n    if (!source.relatedTagIds.includes(filter)) {\n      includesAllFilters = false;\n    }\n  });\n  let searchFound = false;\n\n  if (filterSearchTerm && filterSearchTerm.length >= 3 && source.name.toLocaleLowerCase().includes(filterSearchTerm.toLocaleLowerCase())) {\n    searchFound = true;\n  }\n\n  if (includesAllFilters || filters.includes(source.tagId) || filters.includes(source.parentTagId)) {\n    if (searchFound || !filterSearchTerm || filterSearchTerm.length < 3) {\n      return _.cloneDeep(source);\n    }\n  }\n\n  let result = _.cloneDeep(source);\n\n  result.children = [];\n  source.children.forEach(sourceItem => {\n    let filteredResult = filterResult(sourceItem, filters, filterSearchTerm);\n\n    if (filteredResult) {\n      result.children.push(filteredResult);\n    }\n  });\n\n  if (result.children.length > 0) {\n    result.children = _.sortBy(result.children, [function (c) {\n      return c.name;\n    }]);\n    return result;\n  }\n\n  return undefined;\n};\n\nconst filterOption = (source, filters, filterSearchTerm) => {\n  let includesAllFilters = true;\n  filters.forEach(filter => {\n    if (!source.relatedTagIds.includes(filter)) {\n      includesAllFilters = false;\n    }\n  });\n  let searchFound = false;\n\n  if (filterSearchTerm && filterSearchTerm.length >= 3 && source.name.toLocaleLowerCase().includes(filterSearchTerm.toLocaleLowerCase())) {\n    searchFound = true;\n  }\n\n  if (includesAllFilters || filters.includes(source.tagId) || filters.includes(source.parentTagId)) {\n    if (searchFound || !filterSearchTerm || filterSearchTerm.length < 3) {\n      return _.cloneDeep(source);\n    }\n  }\n\n  let result = _.cloneDeep(source);\n\n  result.items = [];\n  source.items.forEach(sourceItem => {\n    let filteredResult = filterResult(sourceItem, filters, filterSearchTerm);\n\n    if (filteredResult) {\n      result.items.push(filteredResult);\n    }\n  });\n\n  if (result.items.length > 0) {\n    result.items = _.sortBy(result.items, [function (c) {\n      return c.name;\n    }]);\n    return result;\n  }\n\n  return undefined;\n};\n\nconst buildBrowseFiltered = (source, filters, filterSearchTerm) => {\n  // if there is no search or filter return everything\n  if (filters.length === 0 && (!filterSearchTerm || filterSearchTerm.length < 3)) return _.cloneDeep(source); // build a new list of matches\n\n  let result = [];\n  source.forEach(sourceOption => {\n    let filteredOption = filterOption(sourceOption, filters, filterSearchTerm);\n\n    if (filteredOption) {\n      result.push(filteredOption);\n    }\n  });\n  return result;\n};\n\nconst isOnLiveNowPage = stream => {\n  const today = moment();\n  return moment(stream.startTime).isSame(today, 'day');\n};\n\nconst isPlayingNow = stream => {\n  const now = moment();\n  return moment(now).isBetween(moment(stream.startTime).add(-2, 'm'), moment(stream.startTime).add(stream.duration + 30, 'm'));\n};\n\nconst applyAutoTags = state => {\n  var _state$tree;\n\n  // console.log('applyAutoTags')\n  let streams = _.cloneDeep(state.streams) || [];\n  let liveNowTag; // let nowTag: ITag | undefined\n\n  (_state$tree = state.tree) === null || _state$tree === void 0 ? void 0 : _state$tree.forEach(tag => {\n    if (tag.name === 'live-now') {\n      liveNowTag = tag;\n    }\n  }); //console.log('applyAutoTags liveNowTag', liveNowTag)\n  // console.log('applyAutoTags nowTag', nowTag)\n\n  if (!liveNowTag) {\n    // || !nowTag) {\n    return state;\n  }\n\n  let liveNowTagId = liveNowTag.id; // let nowTagid = nowTag.id\n\n  let newList = [];\n  let hasChanged = false;\n  streams.forEach(stream => {\n    if (stream.eventId === 11964) {// debugger\n    }\n\n    let shouldBeOnLiveNowPage = isOnLiveNowPage(stream);\n\n    if (shouldBeOnLiveNowPage && !stream.browseTags.includes(liveNowTagId)) {\n      hasChanged = true;\n      stream.browseTags.push(liveNowTagId);\n    }\n\n    if (!shouldBeOnLiveNowPage && stream.browseTags.includes(liveNowTagId)) {\n      hasChanged = true;\n      const newBrowseTags = [];\n      stream.browseTags.forEach(tag => {\n        if (tag !== liveNowTagId) newBrowseTags.push(tag);\n      });\n      stream.browseTags = newBrowseTags;\n    }\n\n    let shouldBePlayingNow = isPlayingNow(stream);\n  });\n\n  if (hasChanged) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      streams,\n      refreshKey: uuidv4()\n    });\n  }\n\n  return state;\n};\n\nconst tokenReducer = createReducer(initialState, {\n  'PAGE_INITIALIZED': state => _objectSpread({}, state),\n  'PAGE_VISITED': (state, action) => {\n    const x = [...state.visitedTags, action.payload];\n    return _objectSpread(_objectSpread({}, state), {}, {\n      visitedTags: x\n    });\n  },\n  ['POLL_TICKED']: state => {\n    // console.log('tokenReducer POLL_TICKED')\n    return applyAutoTags(state);\n  },\n  ['@userSecurity/token/removed']: state => {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      savedEventIds: [],\n      savedTagIds: []\n    });\n  },\n  [eventTypes.CONTENT_TAGS_SAVEDSTREAMS_RECEIVED]: (state, action) => {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      savedEventIds: action.payload || []\n    });\n  },\n  [eventTypes.CONTENT_TAGS_SAVETAG_TOGGLED]: (state, action) => {\n    if (!action.payload || action.payload === '') return state;\n    const payload = action.payload;\n    const newSavedList = addOrRemoveTag(state.savedTagIds, payload);\n\n    const newState = _objectSpread(_objectSpread({}, state), {}, {\n      savedTagIds: newSavedList\n    });\n\n    return newState;\n  },\n  [eventTypes.CONTENT_TAGS_SAVESTREAM_TOGGLED]: (state, action) => {\n    if (!action.payload) return state;\n    const payload = action.payload;\n    const newSavedList = addOrRemoveStream(state.savedEventIds, payload);\n\n    const newState = _objectSpread(_objectSpread({}, state), {}, {\n      savedEventIds: newSavedList\n    });\n\n    return newState;\n  },\n  [eventTypes.CONTENT_TAGS_RECEIVED]: (state, action) => {\n    const tree = action.payload.tree;\n    const pathIndex = [];\n    const uuidIndex = [];\n    buildIndexes('', undefined, tree, pathIndex, uuidIndex);\n    const browseAll = buildBrowseAll(tree || [], state.streams || [], uuidIndex);\n    const browseFiltered = buildBrowseFiltered(browseAll, state.filters, state.filterSearchTerm);\n\n    const result = _objectSpread(_objectSpread({}, state), {}, {\n      tree,\n      browseAll,\n      browseFiltered,\n      streams: setStreamTags(_.cloneDeep(state.streams), state.uuidIndex),\n      pathIndex,\n      uuidIndex,\n      error: '',\n      errorDescription: '',\n      hasLoadedTags: true\n    });\n\n    return result;\n  },\n  [eventTypes.CONTENT_TAGS_STREAMS_RECEIVED]: (state, action) => {\n    var _streams;\n\n    let streams = action.payload.streams;\n    const tempStreams = []; // const tempDateLimit = new Date(2020, 1, 1)\n\n    const tempDateLimit = new Date(1900, 1, 1);\n    (_streams = streams) === null || _streams === void 0 ? void 0 : _streams.forEach(stream => {\n      if (moment(stream.startTime) > moment(tempDateLimit)) tempStreams.push(stream);\n    });\n    streams = tempStreams;\n    const browseAll = buildBrowseAll(state.tree || [], streams || [], _.cloneDeep(state.uuidIndex));\n    const browseFiltered = buildBrowseFiltered(state.browseAll, state.filters, state.filterSearchTerm);\n    return applyAutoTags(_objectSpread(_objectSpread({}, state), {}, {\n      hasLoadedStreams: true,\n      browseAll,\n      browseFiltered,\n      streams: setStreamTags(streams, state.uuidIndex)\n    }));\n  },\n  [eventTypes.CONTENT_TAGS_FILTER_SELECTED]: (state, action) => {\n    // let filters = state.filters.includes(action.payload) ? [...state.filters] : [...state.filters, action.payload]\n    const uuidIndex = _.cloneDeep(state.uuidIndex);\n\n    let filters = [...state.filters]; //filters.push(action.payload)\n\n    let tagIndex = _.find(uuidIndex, ti => ti.index === action.payload);\n\n    if (tagIndex && tagIndex.tag && tagIndex.tag.children && tagIndex.tag.children.length > 0) {\n      tagIndex.tag.children.forEach(child => {\n        if (!state.filters.includes(child.id)) {\n          if (!state.filters.includes(action.payload)) {\n            filters.push(child.id);\n          }\n        }\n      });\n    } else {\n      if (!state.filters.includes(action.payload)) {\n        filters.push(action.payload);\n      }\n    }\n\n    const payload = action.payload; // filters = removePeers(payload, filters, uuidIndex)\n\n    const browseFiltered = buildBrowseFiltered(state.browseAll, filters, state.filterSearchTerm);\n    return _objectSpread(_objectSpread({}, state), {}, {\n      browseFiltered,\n      filters\n    });\n  },\n  [ROUTER_LOCATION_CHANGE]: (state, action) => {\n    // Preserve filter, Jess request (undo here)\n    // const browseFiltered = buildBrowseFiltered(state.browseAll, [], state.filterSearchTerm)\n    return _objectSpread({}, state);\n  },\n  [eventTypes.CONTENT_TAGS_FILTER_REMOVED]: (state, action) => {\n    const browseFiltered = buildBrowseFiltered(state.browseAll, [], state.filterSearchTerm);\n    return _objectSpread(_objectSpread({}, state), {}, {\n      browseFiltered,\n      filters: []\n    });\n  },\n  [eventTypes.CONTENT_TAGS_FILTER_SEARCH_SELECTED]: (state, action) => {\n    /*const tree = _.cloneDeep(state.tree);\n    const tags = findFilterTag(tree);\n    const searchTag = tags[0];\n     const filterTags = tags.filter(tag => {\n      return _.includes(tag.name.toLowerCase(), action.payload.toLowerCase())\n    }\n    );\n    const filters: ITag[] = [];\n    searchTag.name = action.payload\n    filters.push(searchTag)\n    searchTag.children = filterTags*/\n    const browseFiltered = buildBrowseFiltered(state.browseAll, [], action.payload);\n    return _objectSpread(_objectSpread({}, state), {}, {\n      browseFiltered,\n      filterSearchTerm: action.payload\n    });\n  },\n  [eventTypes.CONTENT_TAGS_FILTER_SEARCH_REMOVED]: (state, action) => {\n    const browseFiltered = buildBrowseFiltered(state.browseAll, [], '');\n    return _objectSpread(_objectSpread({}, state), {}, {\n      browseFiltered,\n      filterSearchTerm: ''\n    });\n  }\n});\nexport default tokenReducer;","map":{"version":3,"sources":["/Users/ognjen/Desktop/spooky.live-ssr/src/services/content/tags/tagsReducer.ts"],"names":["createReducer","_","eventTypes","moment","v4","uuidv4","initialState","tree","undefined","browseAll","browseFiltered","filters","streams","pathIndex","uuidIndex","mainTag","error","errorDescription","hasLoadedTags","hasLoadedStreams","savedEventIds","savedTagIds","filterSearchTerm","refreshKey","visitedTags","encodeTagName","name","toLocaleLowerCase","replace","buildIndexes","base","parent","forEach","element","path","push","index","parentIndex","tag","id","children","setStreamTags","sorted","sortBy","o","startTime","addOrRemoveTag","savedList","itemToAddOrRemove","newSavedList","cloneDeep","includes","filter","item","addOrRemoveStream","findFilterTag","tags","length","ROUTER_LOCATION_CHANGE","findRelatedTagIds","tagId","findRelatedTagIdsResult","stream","browseTags","browseTagId","lineUpTags","tagIndex","find","t","grandParent","uniq","isNumeric","n","isNaN","parseFloat","isFinite","buildBrowseAll","result","branchTag","hideFromBrowse","streamCount","browseOption","parentTagId","items","relatedTagIds","childTag","childBrowseResult","showInAccordion","grandChildTag","grandChildBrowseResult","greatGrandChildTag","greatGrandChildResult","bo","sortString","i","char","num","parseInt","inv","toString","filterResult","source","includesAllFilters","searchFound","sourceItem","filteredResult","c","filterOption","buildBrowseFiltered","sourceOption","filteredOption","isOnLiveNowPage","today","isSame","isPlayingNow","now","isBetween","add","duration","applyAutoTags","state","liveNowTag","liveNowTagId","newList","hasChanged","eventId","shouldBeOnLiveNowPage","newBrowseTags","shouldBePlayingNow","tokenReducer","action","x","payload","CONTENT_TAGS_SAVEDSTREAMS_RECEIVED","CONTENT_TAGS_SAVETAG_TOGGLED","newState","CONTENT_TAGS_SAVESTREAM_TOGGLED","CONTENT_TAGS_RECEIVED","CONTENT_TAGS_STREAMS_RECEIVED","tempStreams","tempDateLimit","Date","CONTENT_TAGS_FILTER_SELECTED","ti","child","CONTENT_TAGS_FILTER_REMOVED","CONTENT_TAGS_FILTER_SEARCH_SELECTED","CONTENT_TAGS_FILTER_SEARCH_REMOVED"],"mappings":"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","sourcesContent":["import { createReducer, Reducer, PayloadAction } from '@reduxjs/toolkit'\nimport _ from 'lodash'\n\nimport * as eventTypes from './eventTypes'\nimport { ITagsState, ITagsResponse, ITag, ITagIndex, IStreamsResponse, IStream, BrowseOption, BrowseResult } from './models'\nimport moment from 'moment'\nimport { v4 as uuidv4 } from 'uuid'\nimport { isNumber } from 'util'\n\nconst initialState: ITagsState = {\n  tree: undefined,\n  // filteredTree: undefined,\n  browseAll: [],\n  browseFiltered: [],\n  filters: [],\n  streams: [],\n  pathIndex: undefined,\n  uuidIndex: undefined,\n  mainTag: undefined,\n  error: '',\n  errorDescription: '',\n  hasLoadedTags: false,\n  hasLoadedStreams: false,\n  savedEventIds: [],\n  savedTagIds: [],\n  filterSearchTerm: '',\n  refreshKey: uuidv4(),\n  visitedTags: []\n}\n\nconst encodeTagName = (name: string): string => {\n  /* eslint-disable */\n  return name.toLocaleLowerCase().replace(/ /gi, '-').replace(/[^0-9a-z\\-]/gi, '').replace(/[-]+/gi, '-').replace(/[-]+/gi, '-')\n  /* eslint-enable */\n}\n\nconst buildIndexes = (base: string, parent: ITag | undefined, tree: ITag[] | undefined, pathIndex: ITagIndex[], uuidIndex: ITagIndex[]) => {\n  if (tree === undefined) return\n\n  tree.forEach(element => {\n    // if (element.name && element.name.length > 20) element.name = element.name.substring(0, 19) + '...'\n\n    let path = `${base}/${encodeTagName(element.name)}`\n    element.path = path\n\n    pathIndex.push({ index: path, parentIndex: base, tag: element })\n    uuidIndex.push({ index: element.id, parentIndex: parent?.id, tag: element })\n    buildIndexes(path, element, element.children, pathIndex, uuidIndex)\n  })\n}\n\nconst setStreamTags = (streams: IStream[] | undefined, uuidIndex: ITagIndex[] | undefined): IStream[] => {\n  if (!streams) return []\n  if (!uuidIndex) return streams\n  // we have a uuidIndex and streams\n\n  // streams.forEach(stream => {\n  // })\n\n  var sorted = _.sortBy<IStream[]>(streams, [function (o: IStream) { return o.startTime; }])\n\n  return sorted\n}\n/*\nconst removePeers = (newFilter: string, filters: string[], uuidIndex: ITagIndex[]): string[] => {\n  // find the parent for the newFilter\n  let newFilterTag: ITagIndex = _.find(uuidIndex, (element: ITagIndex) => element.index === newFilter)\n  let parentTagId = newFilterTag.parentIndex\n  if (parentTagId === undefined) return filters\n  let parentTagIndex: ITagIndex = _.find(uuidIndex, (element: ITagIndex) => element.index === parentTagId)\n  let parentTag = parentTagIndex.tag\n\n  // build a new array that excludes all of newFilter's peers\n  let newFilters: string[] = [newFilter]\n  let peers = parentTag.children || []\n  let peerIds: string[] = []\n  peers.forEach(element => {\n    peerIds.push(element.id)\n  })\n  filters.forEach(element => {\n    if (!peerIds.includes(element)) {\n      newFilters.push(element)\n    }\n  })\n\n  return newFilters\n}\n*/\n\nconst addOrRemoveTag = (savedList: string[], itemToAddOrRemove: string): string[] => {\n  let newSavedList: string[] = _.cloneDeep(savedList) || []\n  if (savedList?.includes(itemToAddOrRemove)) {\n    newSavedList = newSavedList.filter(item => item !== itemToAddOrRemove)\n  } else {\n    newSavedList.push(itemToAddOrRemove)\n  }\n  return newSavedList\n}\n\nconst addOrRemoveStream = (savedList: number[], itemToAddOrRemove: number): number[] => {\n  let newSavedList: number[] = _.cloneDeep(savedList) || []\n  if (savedList?.includes(itemToAddOrRemove)) {\n    newSavedList = newSavedList.filter(item => item !== itemToAddOrRemove)\n  } else {\n    newSavedList.push(itemToAddOrRemove)\n  }\n  return newSavedList\n}\n\nconst findFilterTag = (tree: ITag[] | undefined): ITag[] | [] => {\n  let tags: ITag[] = [];\n  if (!tree)\n    return [];\n  for (const item of tree) {\n    tags.push(item)\n    if (item.children && item.children.length > 0) {\n      tags.push(...findFilterTag(item.children))\n    }\n\n  }\n  return tags;\n}\n\nconst ROUTER_LOCATION_CHANGE = '@@router/LOCATION_CHANGE'\n\nconst findRelatedTagIds = (tagId: string, streams: IStream[], uuidIndex: ITagIndex[]): string[] => {\n  let findRelatedTagIdsResult: string[] = []\n\n  streams.forEach(stream => {\n    if (stream.browseTags.includes(tagId)) {\n      stream.browseTags.forEach(browseTagId => {\n        if (!stream.lineUpTags.includes(browseTagId)) {\n          findRelatedTagIdsResult.push(browseTagId)\n          const tagIndex: ITagIndex = _.find(uuidIndex, (t: ITagIndex) => t.index === browseTagId)\n          if (tagIndex && tagIndex.parentIndex) {\n            findRelatedTagIdsResult.push(tagIndex.parentIndex)\n            var parent: ITagIndex = _.find(uuidIndex, (t: ITagIndex) => t.index === tagIndex.parentIndex)\n            if (parent && parent.parentIndex) {\n              findRelatedTagIdsResult.push(parent.parentIndex)\n              var grandParent: ITagIndex = _.find(uuidIndex, (t: ITagIndex) => t.index === parent.parentIndex)\n              if (grandParent && grandParent.parentIndex) {\n                findRelatedTagIdsResult.push(grandParent.parentIndex)\n              }\n            }\n          }\n        }\n      })\n    }\n  })\n\n  findRelatedTagIdsResult = _.uniq(findRelatedTagIdsResult)\n  return findRelatedTagIdsResult\n}\nconst isNumeric = (n: any): boolean => {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nconst buildBrowseAll = (tree: ITag[], streams: IStream[], uuidIndex: ITagIndex[]): BrowseOption[] => {\n  let result: BrowseOption[] = []\n\n  tree.forEach((branchTag: ITag) => {\n\n    if (!branchTag.hideFromBrowse && branchTag.streamCount !== 0) {\n      let browseOption: BrowseOption = {\n        name: branchTag.name,\n        path: branchTag.path || '',\n        tagId: branchTag.id,\n        parentTagId: branchTag.parent?.id || '',\n        items: [],\n        relatedTagIds: findRelatedTagIds(branchTag.id, streams, uuidIndex)//,\n        //relatedTagNames: findRelatedTagNames(branchTag.id, streams, uuidIndex)\n      }\n      if (branchTag.children && branchTag.children.length > 0) {\n        branchTag.children.forEach(childTag => {\n\n          if (!childTag.hideFromBrowse && childTag.streamCount !== 0) {\n            let childBrowseResult: BrowseResult = {\n              name: childTag.name,\n              tagId: childTag.id,\n              parentTagId: childTag.parent?.id || '',\n              path: childTag.path || '',\n              children: [],\n              showInAccordion: true,\n              relatedTagIds: findRelatedTagIds(childTag.id, streams, uuidIndex)//,\n              //relatedTagNames: findRelatedTagNames(childTag.id, streams, uuidIndex)\n            }\n            browseOption.items.push(childBrowseResult)\n\n            childTag.children?.forEach(grandChildTag => {\n              if (!grandChildTag.hideFromBrowse && grandChildTag.streamCount !== 0)  {\n                let grandChildBrowseResult: BrowseResult = {\n                  name: grandChildTag.name,\n                  tagId: grandChildTag.id,\n                  parentTagId: grandChildTag.parent?.id || '',\n                  path: grandChildTag.path || '',\n                  children: [],\n                  showInAccordion: false,\n                  relatedTagIds: findRelatedTagIds(grandChildTag.id, streams, uuidIndex)//,\n                  //relatedTagNames: findRelatedTagNames(grandChildTag.id, streams, uuidIndex)\n                }\n                browseOption.items.push(grandChildBrowseResult)\n                childBrowseResult.children.push(grandChildBrowseResult)\n  \n                grandChildTag.children?.forEach(greatGrandChildTag => {\n                  let greatGrandChildResult: BrowseResult = {\n                    name: greatGrandChildTag.name,\n                    tagId: greatGrandChildTag.id,\n                    parentTagId: greatGrandChildTag.parent?.id || '',\n                    path: greatGrandChildTag.path || '',\n                    children: [],\n                    showInAccordion: false,\n                    relatedTagIds: findRelatedTagIds(greatGrandChildTag.id, streams, uuidIndex)//,\n                    //relatedTagNames: findRelatedTagNames(greatGrandChildTag.id, streams, uuidIndex)\n                  }\n                  grandChildBrowseResult.children.push(greatGrandChildResult)\n                })\n              }\n            })\n          }\n        })\n        if (browseOption.name !== 'Competitions') {\n          browseOption.items = _.sortBy(browseOption.items, (bo: BrowseOption) => {\n            // Sort by numeric characters descending, then alphanumeric characters ascending\n            let sortString: string = ''\n            for (let i = 0; i < bo.name.length; i++) {\n              // if the character is a number invert it\n              if (isNumeric(bo.name[i])) {\n                let char = bo.name[i]\n                let num = parseInt(char)\n                let inv = 9 - num\n                sortString += inv.toString()\n              } else {\n                // otherwise just add it to the sort string for comparison\n                sortString += bo.name[i]\n              }\n            }\n\n            return sortString\n          })\n        }\n      }\n      result.push(browseOption)\n    }\n\n\n  })\n\n  return result\n}\n\nconst filterResult = (source: BrowseResult, filters: string[], filterSearchTerm: string): BrowseResult | undefined => {\n\n  let includesAllFilters = true // invert to change to include any filter\n  filters.forEach(filter => {\n    if (!source.relatedTagIds.includes(filter)) {\n      includesAllFilters = false\n    }\n  })\n\n  let searchFound: boolean = false\n  if (filterSearchTerm && filterSearchTerm.length >= 3 && source.name.toLocaleLowerCase().includes(filterSearchTerm.toLocaleLowerCase())) {\n    searchFound = true\n  }\n\n  if (includesAllFilters || filters.includes(source.tagId) || filters.includes(source.parentTagId)) {\n    if (searchFound || !filterSearchTerm || filterSearchTerm.length < 3) {\n      return _.cloneDeep(source)\n    }\n  }\n\n  let result: BrowseResult = _.cloneDeep(source)\n  result.children = []\n\n  source.children.forEach(sourceItem => {\n    let filteredResult = filterResult(sourceItem, filters, filterSearchTerm)\n    if (filteredResult) {\n      result.children.push(filteredResult)\n    }\n  })\n\n  if (result.children.length > 0) {\n    result.children = _.sortBy(result.children, [function (c: BrowseResult) { return c.name; }]);\n    return result\n  }\n\n  return undefined\n}\n\nconst filterOption = (source: BrowseOption, filters: string[], filterSearchTerm: string): BrowseOption | undefined => {\n\n  let includesAllFilters = true\n  filters.forEach(filter => {\n    if (!source.relatedTagIds.includes(filter)) {\n      includesAllFilters = false\n    }\n  })\n\n  let searchFound: boolean = false\n  if (filterSearchTerm && filterSearchTerm.length >= 3 && source.name.toLocaleLowerCase().includes(filterSearchTerm.toLocaleLowerCase())) {\n    searchFound = true\n  }\n\n  if (includesAllFilters || filters.includes(source.tagId) || filters.includes(source.parentTagId)) {\n    if (searchFound || !filterSearchTerm || filterSearchTerm.length < 3) {\n      return _.cloneDeep(source)\n    }\n  }\n\n  let result: BrowseOption = _.cloneDeep(source)\n  result.items = []\n\n  source.items.forEach(sourceItem => {\n    let filteredResult = filterResult(sourceItem, filters, filterSearchTerm)\n    if (filteredResult) {\n      result.items.push(filteredResult)\n    }\n  })\n\n  if (result.items.length > 0) {\n    result.items = _.sortBy(result.items, [function (c: BrowseResult) { return c.name; }]);\n    return result\n  }\n\n  return undefined\n}\n\nconst buildBrowseFiltered = (source: BrowseOption[], filters: string[], filterSearchTerm: string): BrowseOption[] => {\n\n  // if there is no search or filter return everything\n  if (filters.length === 0 && (!filterSearchTerm || filterSearchTerm.length < 3)) return _.cloneDeep(source)\n\n  // build a new list of matches\n  let result: BrowseOption[] = []\n\n  source.forEach(sourceOption => {\n    let filteredOption = filterOption(sourceOption, filters, filterSearchTerm)\n    if (filteredOption) {\n      result.push(filteredOption)\n    }\n  })\n\n  return result\n}\n\nconst isOnLiveNowPage = (stream: IStream): boolean => {\n  const today = moment()\n  return moment(stream.startTime).isSame(today, 'day')\n}\n\nconst isPlayingNow = (stream: IStream): boolean => {\n  const now = moment()\n  return moment(now).isBetween(moment(stream.startTime).add(-2, 'm'), moment(stream.startTime).add(stream.duration + 30, 'm'))\n}\n\nconst applyAutoTags = (state: ITagsState) => {\n\n  // console.log('applyAutoTags')\n\n  let streams: IStream[] = _.cloneDeep(state.streams) || []\n  let liveNowTag: ITag | undefined\n  // let nowTag: ITag | undefined\n\n  state.tree?.forEach((tag: ITag) => {\n    if (tag.name === 'live-now') {\n      liveNowTag = tag\n    }\n  })\n\n  //console.log('applyAutoTags liveNowTag', liveNowTag)\n  // console.log('applyAutoTags nowTag', nowTag)\n\n  if (!liveNowTag) { // || !nowTag) {\n    return state\n  }\n\n  let liveNowTagId = liveNowTag.id\n  // let nowTagid = nowTag.id\n\n  let newList: IStream[] = []\n  let hasChanged: boolean = false\n  streams.forEach((stream: IStream) => {\n\n    if (stream.eventId === 11964) {\n      // debugger\n    }\n\n    let shouldBeOnLiveNowPage = isOnLiveNowPage(stream)\n\n    if (shouldBeOnLiveNowPage && !stream.browseTags.includes(liveNowTagId)) {\n      hasChanged = true\n      stream.browseTags.push(liveNowTagId)\n    }\n\n    if (!shouldBeOnLiveNowPage && stream.browseTags.includes(liveNowTagId)) {\n      hasChanged = true\n      const newBrowseTags: string[] = []\n      stream.browseTags.forEach(tag => {\n        if (tag !== liveNowTagId) newBrowseTags.push(tag)\n      })\n      stream.browseTags = newBrowseTags\n    }\n\n    let shouldBePlayingNow = isPlayingNow(stream)\n\n  })\n\n  if (hasChanged) {\n    return { ...state, streams, refreshKey: uuidv4() }\n  }\n\n  return state\n}\n\nconst tokenReducer: Reducer<ITagsState> = createReducer(initialState, {\n  'PAGE_INITIALIZED': (state: ITagsState) => ({...state}),\n  'PAGE_VISITED': (state: ITagsState, action: PayloadAction<any>) => {\n    const x = [...state.visitedTags, action.payload];\n    return ({\n      ...state,\n      visitedTags: x\n    })\n  },\n  ['POLL_TICKED']: (state) => {\n    // console.log('tokenReducer POLL_TICKED')\n    return applyAutoTags(state)\n  },\n  ['@userSecurity/token/removed']: (state) => {\n    return {\n      ...state,\n      savedEventIds: [],\n      savedTagIds: []\n    }\n  },\n  [eventTypes.CONTENT_TAGS_SAVEDSTREAMS_RECEIVED]: (state, action: PayloadAction<number[]>) => {\n    return {\n      ...state,\n      savedEventIds: action.payload || []\n    }\n  },\n  [eventTypes.CONTENT_TAGS_SAVETAG_TOGGLED]: (state, action: PayloadAction<string>) => {\n    if (!action.payload || action.payload === '') return state\n    const payload = action.payload\n    const newSavedList = addOrRemoveTag(state.savedTagIds, payload)\n    const newState: ITagsState = { ...state, savedTagIds: newSavedList }\n    return newState\n  },\n  [eventTypes.CONTENT_TAGS_SAVESTREAM_TOGGLED]: (state, action: PayloadAction<number>) => {\n    if (!action.payload) return state\n    const payload = action.payload\n    const newSavedList = addOrRemoveStream(state.savedEventIds, payload)\n    const newState: ITagsState = { ...state, savedEventIds: newSavedList }\n    return newState\n  },\n  [eventTypes.CONTENT_TAGS_RECEIVED]: (state, action: PayloadAction<ITagsResponse>) => {\n    const tree = action.payload.tree\n    const pathIndex: ITagIndex[] = []\n    const uuidIndex: ITagIndex[] = []\n    buildIndexes('', undefined, tree, pathIndex, uuidIndex)\n    const browseAll = buildBrowseAll(tree || [], state.streams || [], uuidIndex)\n    const browseFiltered = buildBrowseFiltered(browseAll, state.filters, state.filterSearchTerm)\n    const result = {\n      ...state,\n      tree,\n      browseAll,\n      browseFiltered,\n      streams: setStreamTags(_.cloneDeep(state.streams), state.uuidIndex),\n      pathIndex,\n      uuidIndex,\n      error: '',\n      errorDescription: '',\n      hasLoadedTags: true\n    }\n    return result\n  },\n  [eventTypes.CONTENT_TAGS_STREAMS_RECEIVED]: (state, action: PayloadAction<IStreamsResponse>) => {\n    let streams = action.payload.streams\n    const tempStreams: IStream[] = []\n    // const tempDateLimit = new Date(2020, 1, 1)\n    const tempDateLimit = new Date(1900, 1, 1)\n    streams?.forEach(stream => {\n      if (moment(stream.startTime) > moment(tempDateLimit)) tempStreams.push(stream)\n    })\n    streams = tempStreams\n    const browseAll = buildBrowseAll(state.tree || [], streams || [], _.cloneDeep(state.uuidIndex))\n    const browseFiltered = buildBrowseFiltered(state.browseAll, state.filters, state.filterSearchTerm)\n    return applyAutoTags({\n      ...state,\n      hasLoadedStreams: true,\n      browseAll,\n      browseFiltered,\n      streams: setStreamTags(streams, state.uuidIndex)\n    })\n  },\n  [eventTypes.CONTENT_TAGS_FILTER_SELECTED]: (state, action: PayloadAction<string>) => {\n    // let filters = state.filters.includes(action.payload) ? [...state.filters] : [...state.filters, action.payload]\n    const uuidIndex = _.cloneDeep(state.uuidIndex)\n    let filters = [...state.filters]\n\n    //filters.push(action.payload)\n    let tagIndex: ITagIndex = _.find(uuidIndex, (ti) => ti.index === action.payload)\n    if (tagIndex && tagIndex.tag && tagIndex.tag.children && tagIndex.tag.children.length > 0) {\n      tagIndex.tag.children.forEach(child => {\n        if (!state.filters.includes(child.id)) {\n          if (!state.filters.includes(action.payload)) {\n            filters.push(child.id)\n          }\n        }\n      })\n    } else {\n      if (!state.filters.includes(action.payload)) {\n        filters.push(action.payload)\n\n      }\n    }\n\n\n    const payload = action.payload\n    // filters = removePeers(payload, filters, uuidIndex)\n    const browseFiltered = buildBrowseFiltered(state.browseAll, filters, state.filterSearchTerm)\n\n    return {\n      ...state,\n      browseFiltered,\n      filters\n    }\n  },\n  [ROUTER_LOCATION_CHANGE]: (state, action: PayloadAction<string>) => {\n    // Preserve filter, Jess request (undo here)\n    // const browseFiltered = buildBrowseFiltered(state.browseAll, [], state.filterSearchTerm)\n    return {\n      ...state,\n      //browseFiltered,\n      // filters: []\n    }\n  },\n  [eventTypes.CONTENT_TAGS_FILTER_REMOVED]: (state, action: PayloadAction<string>) => {\n    const browseFiltered = buildBrowseFiltered(state.browseAll, [], state.filterSearchTerm)\n    return {\n      ...state,\n      browseFiltered,\n      filters: []\n    }\n  },\n  [eventTypes.CONTENT_TAGS_FILTER_SEARCH_SELECTED]: (state, action: PayloadAction<string>) => {\n    /*const tree = _.cloneDeep(state.tree);\n    const tags = findFilterTag(tree);\n    const searchTag = tags[0];\n\n    const filterTags = tags.filter(tag => {\n      return _.includes(tag.name.toLowerCase(), action.payload.toLowerCase())\n    }\n    );\n    const filters: ITag[] = [];\n    searchTag.name = action.payload\n    filters.push(searchTag)\n    searchTag.children = filterTags*/\n    const browseFiltered = buildBrowseFiltered(state.browseAll, [], action.payload)\n    return {\n      ...state,\n      browseFiltered,\n      filterSearchTerm: action.payload,\n    }\n  },\n  [eventTypes.CONTENT_TAGS_FILTER_SEARCH_REMOVED]: (state, action: PayloadAction<string>) => {\n    const browseFiltered = buildBrowseFiltered(state.browseAll, [], '')\n    return {\n      ...state,\n      browseFiltered,\n      filterSearchTerm: ''\n    }\n  }\n})\n\n\nexport default tokenReducer\n"]},"metadata":{},"sourceType":"module"}